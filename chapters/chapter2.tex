% 第二章：优化模型
% 文件名：chapters/chapter2.tex

\chapter{优化模型}\label{chap:optimization}

优化是数学建模中的重要内容，它涉及在给定约束条件下寻找最优解的问题。本章将介绍优化模型的基本概念、分类和求解方法。

\section{优化问题的基本概念}\label{sec:optimization-concepts}

优化问题是指在满足一定约束条件的前提下，寻找使目标函数达到最大值或最小值的问题。

\begin{definition}[优化问题]\label{def:optimization-problem}
一般的优化问题可以表示为：
\begin{align}
\min/\max \quad & f(x) \\
\text{s.t.} \quad & g_i(x) \leq 0, \quad i = 1, 2, \ldots, m \\
& h_j(x) = 0, \quad j = 1, 2, \ldots, p \\
& x \in \mathbb{R}^n
\end{align}
其中 $f(x)$ 是目标函数，$g_i(x)$ 是不等式约束，$h_j(x)$ 是等式约束。
\end{definition}

\begin{infobox}[title=优化问题的组成要素]
每个优化问题都包含以下三个基本要素：
\begin{itemize}
    \item \textbf{决策变量}：需要确定的变量 $x$
    \item \textbf{目标函数}：要优化的目标 $f(x)$
    \item \textbf{约束条件}：限制条件 $g_i(x), h_j(x)$
\end{itemize}
\end{infobox}

\subsection{优化问题的分类}

根据不同的标准，优化问题可以分为多种类型：

\begin{table}[htbp]
    \centering
    \caption{优化问题的分类}
    \label{tab:optimization-types}
    \begin{tabular}{@{}ll@{}}
        \toprule
        分类标准 & 类型 \\
        \midrule
        \multirow{2}{*}{变量类型} & 连续优化 \\
        & 离散优化 \\
        \midrule
        \multirow{2}{*}{目标函数} & 线性规划 \\
        & 非线性规划 \\
        \midrule
        \multirow{2}{*}{约束条件} & 约束优化 \\
        & 无约束优化 \\
        \midrule
        \multirow{2}{*}{目标个数} & 单目标优化 \\
        & 多目标优化 \\
        \bottomrule
    \end{tabular}
\end{table}

\section{线性规划}\label{sec:linear-programming}

线性规划是最基本的优化问题，其目标函数和约束条件都是线性的。

\begin{definition}[线性规划]\label{def:linear-programming}
线性规划问题的一般形式为：
\begin{align}
\min \quad & c^T x \\
\text{s.t.} \quad & Ax = b \\
& x \geq 0
\end{align}
其中 $c \in \mathbb{R}^n$，$A \in \mathbb{R}^{m \times n}$，$b \in \mathbb{R}^m$。
\end{definition}

\subsection{线性规划的几何意义}

线性规划的可行域是一个凸多面体，最优解必定在该多面体的某个顶点上。

\begin{theorem}[线性规划基本定理]\label{thm:lp-fundamental}
如果线性规划问题有最优解，则必定存在一个顶点最优解。
\end{theorem}

\begin{proof}
设可行域为 $\mathcal{F} = \{x : Ax = b, x \geq 0\}$，目标函数为 $f(x) = c^T x$。

若 $x^*$ 是最优解但不是顶点，则 $x^*$ 可以表示为两个不同可行点的凸组合：
$x^* = \lambda x^1 + (1-\lambda) x^2$，其中 $0 < \lambda < 1$。

由于 $f$ 是线性函数，有：
$f(x^*) = \lambda f(x^1) + (1-\lambda) f(x^2)$

若 $x^*$ 是最优解，则 $f(x^*) \leq f(x^1)$ 且 $f(x^*) \leq f(x^2)$，
这意味着 $f(x^*) = f(x^1) = f(x^2)$，矛盾。
\end{proof}

\begin{examplebox}[title=生产计划问题]
某工厂生产两种产品 A 和 B，每单位产品的利润分别为 3 和 2。
生产受到以下约束：
\begin{itemize}
    \item 原料限制：$2x_1 + x_2 \leq 100$
    \item 设备限制：$x_1 + x_2 \leq 80$
    \item 非负约束：$x_1, x_2 \geq 0$
\end{itemize}

线性规划模型为：
\begin{align}
\max \quad & 3x_1 + 2x_2 \\
\text{s.t.} \quad & 2x_1 + x_2 \leq 100 \\
& x_1 + x_2 \leq 80 \\
& x_1, x_2 \geq 0
\end{align}
\end{examplebox}

\subsection{单纯形法}

单纯形法是求解线性规划的经典算法。

\begin{codebox}[title=Python 求解线性规划]
使用 SciPy 库求解上述生产计划问题：
\begin{lstlisting}[language=Python]
from scipy.optimize import linprog
import numpy as np

# 目标函数系数（注意：linprog 求最小值，所以取负号）
c = np.array([-3, -2])

# 不等式约束系数矩阵和右端项
A_ub = np.array([[2, 1], [1, 1]])
b_ub = np.array([100, 80])

# 变量的上下界
x_bounds = [(0, None), (0, None)]

# 求解
result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=x_bounds, method='highs')

print("最优解：", result.x)
print("最优值：", -result.fun)
\end{lstlisting}
\end{codebox}

\section{非线性规划}\label{sec:nonlinear-programming}

当目标函数或约束条件中包含非线性函数时，就构成了非线性规划问题。

\begin{definition}[非线性规划]\label{def:nonlinear-programming}
非线性规划问题的一般形式为：
\begin{align}
\min \quad & f(x) \\
\text{s.t.} \quad & g_i(x) \leq 0, \quad i = 1, 2, \ldots, m \\
& h_j(x) = 0, \quad j = 1, 2, \ldots, p
\end{align}
其中 $f(x)$、$g_i(x)$ 或 $h_j(x)$ 中至少有一个是非线性函数。
\end{definition}

\subsection{KKT 条件}

对于约束非线性规划问题，KKT 条件是最优性的必要条件。

\begin{theorem}[KKT 条件]\label{thm:kkt-conditions}
设 $x^*$ 是约束优化问题的局部最优解，且约束规范条件成立，则存在拉格朗日乘子 $\lambda_i^* \geq 0$ 和 $\mu_j^*$，使得：
\begin{align}
\nabla f(x^*) + \sum_{i=1}^m \lambda_i^* \nabla g_i(x^*) + \sum_{j=1}^p \mu_j^* \nabla h_j(x^*) &= 0 \\
g_i(x^*) &\leq 0, \quad i = 1, 2, \ldots, m \\
h_j(x^*) &= 0, \quad j = 1, 2, \ldots, p \\
\lambda_i^* &\geq 0, \quad i = 1, 2, \ldots, m \\
\lambda_i^* g_i(x^*) &= 0, \quad i = 1, 2, \ldots, m
\end{align}
\end{theorem}

\begin{warningbox}[title=注意]
KKT 条件只是最优性的必要条件，不是充分条件。对于凸优化问题，KKT 条件既是必要条件也是充分条件。
\end{warningbox}

\subsection{凸优化}

凸优化是非线性规划的一个重要分支，它具有良好的理论性质和计算性质。

\begin{definition}[凸优化问题]\label{def:convex-optimization}
如果优化问题满足：
\begin{itemize}
    \item 目标函数 $f(x)$ 是凸函数
    \item 不等式约束函数 $g_i(x)$ 是凸函数
    \item 等式约束函数 $h_j(x)$ 是仿射函数
\end{itemize}
则称该问题为凸优化问题。
\end{definition}

\begin{property}[凸优化的性质]\label{prop:convex-properties}
凸优化问题具有以下重要性质：
\begin{enumerate}
    \item 局部最优解就是全局最优解
    \item KKT 条件是最优性的充分必要条件
    \item 存在高效的求解算法
\end{enumerate}
\end{property}

\section{动态规划}\label{sec:dynamic-programming}

动态规划是求解多阶段决策问题的一种方法，特别适用于具有最优子结构性质的问题。

\begin{definition}[动态规划]\label{def:dynamic-programming}
动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
\end{definition}

\subsection{动态规划的基本要素}

动态规划问题必须具备以下要素：

\begin{description}
    \item[状态] 问题的状态空间
    \item[决策] 在每个状态下可以采取的行动
    \item[状态转移方程] 描述状态之间转移关系的方程
    \item[边界条件] 问题的初始条件或终止条件
    \item[最优性原理] 问题的最优子结构性质
\end{description}

\begin{example}[背包问题]\label{ex:knapsack}
有 $n$ 个物品和一个容量为 $W$ 的背包。第 $i$ 个物品的重量为 $w_i$，价值为 $v_i$。
要求选择物品放入背包，使得总价值最大且总重量不超过 $W$。
\end{example}

\begin{examplebox}[title=0-1 背包问题的动态规划解法]
设 $f(i, w)$ 表示前 $i$ 个物品放入容量为 $w$ 的背包中的最大价值，则有：

\[
f(i, w) = \begin{cases}
0 & \text{if } i = 0 \text{ or } w = 0 \\
f(i-1, w) & \text{if } w_i > w \\
\max\{f(i-1, w), f(i-1, w-w_i) + v_i\} & \text{if } w_i \leq w
\end{cases}
\]

最优解为 $f(n, W)$。
\end{examplebox}

\begin{codebox}[title=背包问题的 Python 实现]
\begin{lstlisting}[language=Python]
def knapsack(weights, values, capacity):
    n = len(weights)
    # 创建 DP 表
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
    
    # 填充 DP 表
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w-weights[i-1]] + values[i-1]
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]

# 示例
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
capacity = 5

max_value = knapsack(weights, values, capacity)
print(f"最大价值: {max_value}")
\end{lstlisting}
\end{codebox}

\section{启发式算法}\label{sec:heuristic-algorithms}

对于复杂的优化问题，传统的精确算法可能无法在合理时间内找到最优解。启发式算法提供了一种获得近似最优解的方法。

\subsection{遗传算法}

遗传算法是模拟生物进化过程的启发式算法。

\begin{algorithm}[H]
\caption{遗传算法}\label{alg:genetic-algorithm}
\begin{algorithmic}[1]
\State 初始化种群
\While{未满足终止条件}
    \State 计算适应度
    \State 选择操作
    \State 交叉操作
    \State 变异操作
    \State 更新种群
\EndWhile
\State 返回最优解
\end{algorithmic}
\end{algorithm}

\begin{successbox}[title=遗传算法的优点]
\begin{itemize}
    \item 全局搜索能力强
    \item 不需要梯度信息
    \item 适用于离散优化问题
    \item 并行性好
\end{itemize}
\end{successbox}

\subsection{模拟退火算法}

模拟退火算法模拟物理退火过程，能够跳出局部最优解。

\begin{codebox}[title=模拟退火算法实现]
\begin{lstlisting}[language=Python]
import math
import random

def simulated_annealing(objective_func, initial_solution, 
                       neighbor_func, initial_temp, cooling_rate, 
                       min_temp, max_iterations):
    current_solution = initial_solution
    current_cost = objective_func(current_solution)
    best_solution = current_solution
    best_cost = current_cost
    
    temperature = initial_temp
    
    for iteration in range(max_iterations):
        if temperature < min_temp:
            break
            
        # 生成邻域解
        neighbor = neighbor_func(current_solution)
        neighbor_cost = objective_func(neighbor)
        
        # 计算接受概率
        if neighbor_cost < current_cost:
            accept_prob = 1.0
        else:
            accept_prob = math.exp(-(neighbor_cost - current_cost) / temperature)
        
        # 决定是否接受
        if random.random() < accept_prob:
            current_solution = neighbor
            current_cost = neighbor_cost
            
            if current_cost < best_cost:
                best_solution = current_solution
                best_cost = current_cost
        
        # 降温
        temperature *= cooling_rate
    
    return best_solution, best_cost
\end{lstlisting}
\end{codebox}

\section{多目标优化}\label{sec:multi-objective-optimization}

在实际问题中，经常需要同时优化多个目标，这就产生了多目标优化问题。

\begin{definition}[多目标优化问题]\label{def:multi-objective}
多目标优化问题可以表示为：
\begin{align}
\min \quad & F(x) = (f_1(x), f_2(x), \ldots, f_k(x)) \\
\text{s.t.} \quad & x \in \mathcal{X}
\end{align}
其中 $\mathcal{X}$ 是可行域。
\end{definition}

\subsection{帕累托最优}

由于多个目标之间通常存在冲突，多目标优化的解不是单一的最优解，而是一个解集。

\begin{definition}[帕累托最优]\label{def:pareto-optimal}
解 $x^*$ 是帕累托最优的，当且仅当不存在其他解 $x$ 使得：
\begin{itemize}
    \item $f_i(x) \leq f_i(x^*)$ 对所有 $i = 1, 2, \ldots, k$
    \item 至少存在一个 $j$ 使得 $f_j(x) < f_j(x^*)$
\end{itemize}
\end{definition}

\begin{errorbox}[title=常见误区]
在多目标优化中，不能简单地将多个目标函数相加或取加权平均，因为这样会丢失解的多样性。
\end{errorbox}

\section{本章小结}\label{sec:chapter2-summary}

本章介绍了优化模型的基本概念和主要方法，包括：

\begin{itemize}
    \item 优化问题的基本概念和分类
    \item 线性规划的理论和算法
    \item 非线性规划的KKT条件和凸优化
    \item 动态规划的基本思想和应用
    \item 启发式算法的原理和实现
    \item 多目标优化的帕累托最优概念
\end{itemize}

\begin{definitionbox}[title=本章要点]
优化是数学建模的重要工具，掌握各种优化方法对于解决实际问题具有重要意义。选择合适的优化方法需要考虑问题的特点和计算资源的限制。
\end{definitionbox}

\section*{习题}

\begin{enumerate}
    \item 建立并求解一个线性规划问题，解释其几何意义。
    
    \item 证明凸函数的局部最优解是全局最优解。
    
    \item 实现动态规划算法求解最长公共子序列问题。
    
    \item 比较遗传算法和模拟退火算法的优缺点。
    
    \item 设计一个多目标优化问题，并分析其帕累托前沿。
\end{enumerate} 